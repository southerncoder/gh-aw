// @ts-check
import { describe, it, expect, beforeEach, vi } from "vitest";

// Mock core and context globals
const mockCore = {
  info: vi.fn(),
  warning: vi.fn(),
  error: vi.fn(),
  summary: {
    addRaw: vi.fn().mockReturnThis(),
    write: vi.fn(),
  },
};

const mockContext = {
  repo: {
    owner: "testowner",
    repo: "testrepo",
  },
};

global.core = mockCore;
global.context = mockContext;

describe("close_expired_pull_requests", () => {
  let mockGithub;

  beforeEach(() => {
    vi.clearAllMocks();
    mockGithub = {
      graphql: vi.fn(),
      rest: {
        issues: {
          createComment: vi.fn(),
        },
        pulls: {
          update: vi.fn(),
        },
      },
    };
    global.github = mockGithub;
  });

  describe("main - no pull requests found", () => {
    it("should handle case when no pull requests with expiration markers exist", async () => {
      const module = await import("./close_expired_pull_requests.cjs");

      // Mock the search query to return no pull requests
      mockGithub.graphql.mockResolvedValueOnce({
        repository: {
          pullRequests: {
            pageInfo: {
              hasNextPage: false,
              endCursor: null,
            },
            nodes: [],
          },
        },
      });

      await module.main();

      // Verify that summary was written
      expect(mockCore.summary.addRaw).toHaveBeenCalledWith(expect.stringContaining("No pull requests with expiration markers found"));
      expect(mockCore.summary.write).toHaveBeenCalled();
    });
  });

  describe("main - expired pull request", () => {
    it("should close an expired pull request", async () => {
      const module = await import("./close_expired_pull_requests.cjs");

      // Mock the search query to return an open pull request with expiration marker
      mockGithub.graphql.mockResolvedValueOnce({
        repository: {
          pullRequests: {
            pageInfo: {
              hasNextPage: false,
              endCursor: null,
            },
            nodes: [
              {
                id: "PR_test123",
                number: 456,
                title: "Test Pull Request",
                url: "https://github.com/testowner/testrepo/pull/456",
                body: "<!-- gh-aw-workflow-id: test-workflow -->\n> AI generated by Test Workflow\n>\n> - [x] expires <!-- gh-aw-expires: 2020-01-20T09:20:00.000Z --> on Jan 20, 2020, 9:20 AM UTC",
                createdAt: "2020-01-19T09:20:00.000Z",
              },
            ],
          },
        },
      });

      // Mock createComment and update (close PR) responses
      mockGithub.rest.issues.createComment.mockResolvedValueOnce({
        data: {
          id: 12345,
          url: "https://github.com/testowner/testrepo/pull/456#issuecomment-12345",
        },
      });

      mockGithub.rest.pulls.update.mockResolvedValueOnce({
        data: {
          id: 456,
          state: "closed",
          url: "https://github.com/testowner/testrepo/pull/456",
        },
      });

      await module.main();

      // Verify that comment was added
      expect(mockGithub.rest.issues.createComment).toHaveBeenCalledWith({
        owner: "testowner",
        repo: "testrepo",
        issue_number: 456,
        body: expect.stringContaining("automatically closed because it expired"),
      });

      // Verify that pull request was closed
      expect(mockGithub.rest.pulls.update).toHaveBeenCalledWith({
        owner: "testowner",
        repo: "testrepo",
        pull_number: 456,
        state: "closed",
      });

      // Verify that success was logged
      expect(mockCore.info).toHaveBeenCalledWith(expect.stringContaining("Successfully processed pull request #456"));

      // Verify that summary was written with closed PR
      expect(mockCore.summary.addRaw).toHaveBeenCalledWith(expect.stringContaining("Successfully Closed Pull Requests"));
      expect(mockCore.summary.write).toHaveBeenCalled();
    });
  });

  describe("main - not expired pull request", () => {
    it("should skip pull request that is not yet expired", async () => {
      const module = await import("./close_expired_pull_requests.cjs");

      // Mock the search query to return an open pull request with future expiration
      const futureDate = new Date();
      futureDate.setDate(futureDate.getDate() + 7); // 7 days in future

      mockGithub.graphql.mockResolvedValueOnce({
        repository: {
          pullRequests: {
            pageInfo: {
              hasNextPage: false,
              endCursor: null,
            },
            nodes: [
              {
                id: "PR_test456",
                number: 789,
                title: "Future Pull Request",
                url: "https://github.com/testowner/testrepo/pull/789",
                body: `<!-- gh-aw-workflow-id: test-workflow -->\n> AI generated by Test Workflow\n>\n> - [x] expires <!-- gh-aw-expires: ${futureDate.toISOString()} --> on ${futureDate.toLocaleString("en-US", { dateStyle: "medium", timeStyle: "short", timeZone: "UTC" })} UTC`,
                createdAt: new Date().toISOString(),
              },
            ],
          },
        },
      });

      await module.main();

      // Verify that comment was NOT added
      expect(mockGithub.rest.issues.createComment).not.toHaveBeenCalled();

      // Verify that pull request was NOT closed
      expect(mockGithub.rest.pulls.update).not.toHaveBeenCalled();

      // Verify that info was logged about not expired
      expect(mockCore.info).toHaveBeenCalledWith(expect.stringContaining("is NOT expired"));

      // Verify that summary was written with not expired PR
      expect(mockCore.summary.addRaw).toHaveBeenCalledWith(expect.stringContaining("**Not yet expired**: 1 pull request(s)"));
      expect(mockCore.summary.write).toHaveBeenCalled();
    });
  });

  describe("main - error handling", () => {
    it("should handle errors when closing pull request", async () => {
      const module = await import("./close_expired_pull_requests.cjs");

      // Mock the search query to return an open pull request with expiration marker
      mockGithub.graphql.mockResolvedValueOnce({
        repository: {
          pullRequests: {
            pageInfo: {
              hasNextPage: false,
              endCursor: null,
            },
            nodes: [
              {
                id: "PR_error123",
                number: 999,
                title: "Error Pull Request",
                url: "https://github.com/testowner/testrepo/pull/999",
                body: "<!-- gh-aw-workflow-id: test-workflow -->\n> AI generated by Test Workflow\n>\n> - [x] expires <!-- gh-aw-expires: 2020-01-20T09:20:00.000Z --> on Jan 20, 2020, 9:20 AM UTC",
                createdAt: "2020-01-19T09:20:00.000Z",
              },
            ],
          },
        },
      });

      // Mock createComment to throw error
      mockGithub.rest.issues.createComment.mockRejectedValueOnce(new Error("API error"));

      await module.main();

      // Verify that error was logged
      expect(mockCore.error).toHaveBeenCalledWith(expect.stringContaining("Failed to close pull request #999"));

      // Verify that summary includes failed PR
      expect(mockCore.summary.addRaw).toHaveBeenCalledWith(expect.stringContaining("Failed to Close"));
      expect(mockCore.summary.write).toHaveBeenCalled();
    });
  });

  describe("main - pagination", () => {
    it("should handle paginated results", async () => {
      const module = await import("./close_expired_pull_requests.cjs");

      // Mock the search query to return paginated results
      mockGithub.graphql
        // First page
        .mockResolvedValueOnce({
          repository: {
            pullRequests: {
              pageInfo: {
                hasNextPage: true,
                endCursor: "cursor123",
              },
              nodes: [
                {
                  id: "PR_page1",
                  number: 100,
                  title: "Page 1 PR",
                  url: "https://github.com/testowner/testrepo/pull/100",
                  body: "<!-- gh-aw-workflow-id: test-workflow -->\n> AI generated by Test Workflow\n>\n> - [x] expires <!-- gh-aw-expires: 2020-01-20T09:20:00.000Z --> on Jan 20, 2020, 9:20 AM UTC",
                  createdAt: "2020-01-19T09:20:00.000Z",
                },
              ],
            },
          },
        })
        // Second page
        .mockResolvedValueOnce({
          repository: {
            pullRequests: {
              pageInfo: {
                hasNextPage: false,
                endCursor: null,
              },
              nodes: [
                {
                  id: "PR_page2",
                  number: 200,
                  title: "Page 2 PR",
                  url: "https://github.com/testowner/testrepo/pull/200",
                  body: "<!-- gh-aw-workflow-id: test-workflow -->\n> AI generated by Test Workflow\n>\n> - [x] expires <!-- gh-aw-expires: 2020-01-20T09:20:00.000Z --> on Jan 20, 2020, 9:20 AM UTC",
                  createdAt: "2020-01-19T09:20:00.000Z",
                },
              ],
            },
          },
        });

      // Mock REST API calls
      mockGithub.rest.issues.createComment.mockResolvedValue({ data: { id: 1 } });
      mockGithub.rest.pulls.update.mockResolvedValue({ data: { id: 1, state: "closed" } });

      await module.main();

      // Verify that GraphQL was called twice (pagination)
      expect(mockGithub.graphql).toHaveBeenCalledTimes(2);

      // Verify that both PRs were processed
      expect(mockGithub.rest.issues.createComment).toHaveBeenCalledTimes(2);
      expect(mockGithub.rest.pulls.update).toHaveBeenCalledTimes(2);

      // Verify that summary shows 2 PRs closed
      expect(mockCore.summary.addRaw).toHaveBeenCalledWith(expect.stringContaining("Successfully closed: 2 pull request(s)"));
    });
  });
});
