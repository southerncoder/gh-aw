// @ts-check
/// <reference types="@actions/github-script" />

/**
 * Safe Output Type Validator
 *
 * A data-driven validation engine for safe output types.
 * Validation rules are loaded from GH_AW_VALIDATION_CONFIG environment variable,
 * which is generated by the Go compiler from the single source of truth.
 */

const { sanitizeContent } = require("./sanitize_content.cjs");
const { isTemporaryId } = require("./temporary_id.cjs");
const { getErrorMessage } = require("./error_helpers.cjs");
const { unfenceMarkdown } = require("./markdown_unfencing.cjs");

/**
 * Default max body length for GitHub content
 */
const MAX_BODY_LENGTH = 65000;

/**
 * Maximum length for GitHub usernames
 * Reference: https://github.com/dead-claudia/github-limits
 */
const MAX_GITHUB_USERNAME_LENGTH = 39;

/**
 * @typedef {{ allowedAliases?: string[], maxBotMentions?: number }} ValidateOptions
 */

/**
 * @typedef {Object} FieldValidation
 * @property {boolean} [required] - Whether the field is required
 * @property {string} [type] - Expected type: 'string', 'number', 'boolean', 'array'
 * @property {boolean} [sanitize] - Whether to sanitize string content
 * @property {number} [maxLength] - Maximum length for strings
 * @property {boolean} [positiveInteger] - Must be a positive integer
 * @property {boolean} [optionalPositiveInteger] - Optional but if present must be positive integer
 * @property {boolean} [issueOrPRNumber] - Can be issue/PR number or undefined
 * @property {boolean} [issueNumberOrTemporaryId] - Can be issue number or temporary ID
 * @property {string[]} [enum] - Allowed values for the field
 * @property {string} [itemType] - For arrays, the type of items
 * @property {boolean} [itemSanitize] - For arrays, whether to sanitize items
 * @property {number} [itemMaxLength] - For arrays, max length per item
 * @property {string} [pattern] - Regex pattern the value must match
 * @property {string} [patternError] - Error message for pattern mismatch
 */

/**
 * @typedef {Object} TypeValidationConfig
 * @property {number} defaultMax - Default max count for this type
 * @property {Object.<string, FieldValidation>} fields - Field validation rules
 * @property {string} [customValidation] - Custom validation rule identifier
 */

/** @type {Object.<string, TypeValidationConfig>|null} */
let cachedValidationConfig = null;

/**
 * Load validation configuration from environment variable
 * @returns {Object.<string, TypeValidationConfig>}
 */
function loadValidationConfig() {
  if (cachedValidationConfig !== null) {
    return cachedValidationConfig;
  }

  const configJson = process.env.GH_AW_VALIDATION_CONFIG;
  if (!configJson) {
    // Return empty config if not provided - validation will be skipped
    cachedValidationConfig = {};
    return cachedValidationConfig;
  }

  try {
    /** @type {Object.<string, TypeValidationConfig>} */
    const parsed = JSON.parse(configJson);
    cachedValidationConfig = parsed || {};
    return cachedValidationConfig;
  } catch (error) {
    const errorMsg = getErrorMessage(error);
    // Log as error since missing validation config is critical
    if (typeof core !== "undefined") {
      core.error(`CRITICAL: Failed to parse validation config: ${errorMsg}. Validation will be skipped.`);
    }
    cachedValidationConfig = {};
    return cachedValidationConfig;
  }
}

/**
 * Reset the cached validation config (for testing)
 */
function resetValidationConfigCache() {
  cachedValidationConfig = null;
}

/**
 * Get the default max count for a type
 * @param {string} itemType - The safe output type
 * @param {Object} [config] - Configuration override from safe-outputs config
 * @returns {number} The max allowed count
 */
function getMaxAllowedForType(itemType, config) {
  const itemConfig = config?.[itemType];
  if (itemConfig && typeof itemConfig === "object" && "max" in itemConfig && itemConfig.max) {
    return itemConfig.max;
  }
  const validationConfig = loadValidationConfig();
  const typeConfig = validationConfig[itemType];
  return typeConfig?.defaultMax ?? 1;
}

/**
 * Get the minimum required count for a type
 * @param {string} itemType - The safe output type
 * @param {Object} [config] - Configuration from safe-outputs config
 * @returns {number} The minimum required count
 */
function getMinRequiredForType(itemType, config) {
  const itemConfig = config?.[itemType];
  if (itemConfig && typeof itemConfig === "object" && "min" in itemConfig && itemConfig.min) {
    return itemConfig.min;
  }
  return 0;
}

/**
 * Validate a positive integer field
 * @param {any} value - Value to validate
 * @param {string} fieldName - Field name for error messages
 * @param {number} lineNum - Line number for error messages
 * @returns {{isValid: boolean, normalizedValue?: number, error?: string}}
 */
function validatePositiveInteger(value, fieldName, lineNum) {
  if (value === undefined || value === null) {
    return {
      isValid: false,
      error: `Line ${lineNum}: ${fieldName} is required`,
    };
  }
  if (typeof value !== "number" && typeof value !== "string") {
    return {
      isValid: false,
      error: `Line ${lineNum}: ${fieldName} must be a number or string`,
    };
  }
  const parsed = typeof value === "string" ? parseInt(value, 10) : value;
  if (isNaN(parsed) || parsed <= 0 || !Number.isInteger(parsed)) {
    return {
      isValid: false,
      error: `Line ${lineNum}: ${fieldName} must be a valid positive integer (got: ${value})`,
    };
  }
  return { isValid: true, normalizedValue: parsed };
}

/**
 * Validate an optional positive integer field
 * @param {any} value - Value to validate
 * @param {string} fieldName - Field name for error messages
 * @param {number} lineNum - Line number for error messages
 * @returns {{isValid: boolean, normalizedValue?: number, error?: string}}
 */
function validateOptionalPositiveInteger(value, fieldName, lineNum) {
  if (value === undefined) {
    return { isValid: true };
  }
  if (typeof value !== "number" && typeof value !== "string") {
    return {
      isValid: false,
      error: `Line ${lineNum}: ${fieldName} must be a number or string`,
    };
  }
  const parsed = typeof value === "string" ? parseInt(value, 10) : value;
  if (isNaN(parsed) || parsed <= 0 || !Number.isInteger(parsed)) {
    return {
      isValid: false,
      error: `Line ${lineNum}: ${fieldName} must be a valid positive integer (got: ${value})`,
    };
  }
  return { isValid: true, normalizedValue: parsed };
}

/**
 * Validate an issue/PR number field (optional, accepts number or string)
 * @param {any} value - Value to validate
 * @param {string} fieldName - Field name for error messages
 * @param {number} lineNum - Line number for error messages
 * @returns {{isValid: boolean, error?: string}}
 */
function validateIssueOrPRNumber(value, fieldName, lineNum) {
  if (value === undefined) {
    return { isValid: true };
  }
  if (typeof value !== "number" && typeof value !== "string") {
    return {
      isValid: false,
      error: `Line ${lineNum}: ${fieldName} must be a number or string`,
    };
  }
  return { isValid: true };
}

/**
 * Validate a value that can be either a positive integer (issue number) or a temporary ID.
 * @param {any} value - The value to validate
 * @param {string} fieldName - Name of the field for error messages
 * @param {number} lineNum - Line number for error messages
 * @returns {{isValid: boolean, normalizedValue?: number|string, isTemporary?: boolean, error?: string}}
 */
function validateIssueNumberOrTemporaryId(value, fieldName, lineNum) {
  if (value === undefined || value === null) {
    return {
      isValid: false,
      error: `Line ${lineNum}: ${fieldName} is required`,
    };
  }
  if (typeof value !== "number" && typeof value !== "string") {
    return {
      isValid: false,
      error: `Line ${lineNum}: ${fieldName} must be a number or string`,
    };
  }
  // Check if it's a temporary ID
  if (isTemporaryId(value)) {
    return { isValid: true, normalizedValue: String(value).toLowerCase(), isTemporary: true };
  }
  // Try to parse as positive integer
  const parsed = typeof value === "string" ? parseInt(value, 10) : value;
  if (isNaN(parsed) || parsed <= 0 || !Number.isInteger(parsed)) {
    return {
      isValid: false,
      error: `Line ${lineNum}: ${fieldName} must be a positive integer or temporary ID (got: ${value})`,
    };
  }
  return { isValid: true, normalizedValue: parsed, isTemporary: false };
}

/**
 * Validate a single field based on its validation configuration
 * @param {any} value - The field value
 * @param {string} fieldName - The field name
 * @param {FieldValidation} validation - The validation configuration
 * @param {string} itemType - The item type for error messages
 * @param {number} lineNum - Line number for error messages
 * @param {ValidateOptions} [options] - Optional sanitization options
 * @returns {{isValid: boolean, normalizedValue?: any, error?: string}}
 */
function validateField(value, fieldName, validation, itemType, lineNum, options) {
  // For positiveInteger fields, delegate required check to validatePositiveInteger
  if (validation.positiveInteger) {
    return validatePositiveInteger(value, `${itemType} '${fieldName}'`, lineNum);
  }

  // For issueNumberOrTemporaryId fields, delegate required check to validateIssueNumberOrTemporaryId
  if (validation.issueNumberOrTemporaryId) {
    // If the field is optional and not present, skip validation
    if (!validation.required && (value === undefined || value === null)) {
      return { isValid: true };
    }
    return validateIssueNumberOrTemporaryId(value, `${itemType} '${fieldName}'`, lineNum);
  }

  // Handle required check for other fields
  if (validation.required && (value === undefined || value === null)) {
    const fieldType = validation.type || "string";
    return {
      isValid: false,
      error: `Line ${lineNum}: ${itemType} requires a '${fieldName}' field (${fieldType})`,
    };
  }

  // If not required and not present, skip other validations
  if (value === undefined || value === null) {
    return { isValid: true };
  }

  // Handle optionalPositiveInteger validation
  if (validation.optionalPositiveInteger) {
    return validateOptionalPositiveInteger(value, `${itemType} '${fieldName}'`, lineNum);
  }

  // Handle issueOrPRNumber validation
  if (validation.issueOrPRNumber) {
    return validateIssueOrPRNumber(value, `${itemType} '${fieldName}'`, lineNum);
  }

  // Handle type validation
  if (validation.type === "string") {
    if (typeof value !== "string") {
      // For required fields, use "requires a" format for both missing and wrong type
      if (validation.required) {
        return {
          isValid: false,
          error: `Line ${lineNum}: ${itemType} requires a '${fieldName}' field (string)`,
        };
      }
      return {
        isValid: false,
        error: `Line ${lineNum}: ${itemType} '${fieldName}' must be a string`,
      };
    }

    // Handle pattern validation
    if (validation.pattern) {
      const regex = new RegExp(validation.pattern);
      if (!regex.test(value.trim())) {
        const errorMsg = validation.patternError || `must match pattern ${validation.pattern}`;
        return {
          isValid: false,
          error: `Line ${lineNum}: ${itemType} '${fieldName}' ${errorMsg}`,
        };
      }
    }

    // Handle enum validation
    if (validation.enum) {
      const normalizedValue = value.toLowerCase ? value.toLowerCase() : value;
      const normalizedEnum = validation.enum.map(e => (e.toLowerCase ? e.toLowerCase() : e));
      if (!normalizedEnum.includes(normalizedValue)) {
        // Use special format for 2-option enums: "'field' must be 'A' or 'B'"
        // Use standard format for more options: "'field' must be one of: A, B, C"
        let errorMsg;
        if (validation.enum.length === 2) {
          errorMsg = `Line ${lineNum}: ${itemType} '${fieldName}' must be '${validation.enum[0]}' or '${validation.enum[1]}'`;
        } else {
          errorMsg = `Line ${lineNum}: ${itemType} '${fieldName}' must be one of: ${validation.enum.join(", ")}`;
        }
        return {
          isValid: false,
          error: errorMsg,
        };
      }
      // Return the properly cased enum value if there's a case difference
      const matchIndex = normalizedEnum.indexOf(normalizedValue);
      let normalizedResult = validation.enum[matchIndex];
      // Apply sanitization if configured
      if (validation.sanitize && validation.maxLength) {
        normalizedResult = sanitizeContent(normalizedResult, {
          maxLength: validation.maxLength,
          allowedAliases: options?.allowedAliases || [],
          maxBotMentions: options?.maxBotMentions,
        });
      }
      return { isValid: true, normalizedValue: normalizedResult };
    }

    // Handle sanitization
    if (validation.sanitize) {
      // Apply unfencing to remove accidental outer markdown fences before sanitization
      let processedValue = unfenceMarkdown(value);
      const sanitized = sanitizeContent(processedValue, {
        maxLength: validation.maxLength || MAX_BODY_LENGTH,
        allowedAliases: options?.allowedAliases || [],
        maxBotMentions: options?.maxBotMentions,
      });
      return { isValid: true, normalizedValue: sanitized };
    }

    return { isValid: true, normalizedValue: value };
  }

  if (validation.type === "array") {
    if (!Array.isArray(value)) {
      // For required fields, use "requires a" format for both missing and wrong type
      if (validation.required) {
        return {
          isValid: false,
          error: `Line ${lineNum}: ${itemType} requires a '${fieldName}' field (array)`,
        };
      }
      return {
        isValid: false,
        error: `Line ${lineNum}: ${itemType} '${fieldName}' must be an array`,
      };
    }

    // Validate array items
    if (validation.itemType === "string") {
      const hasInvalidItem = value.some(item => typeof item !== "string");
      if (hasInvalidItem) {
        return {
          isValid: false,
          error: `Line ${lineNum}: ${itemType} ${fieldName} array must contain only strings`,
        };
      }

      // Sanitize items if configured
      if (validation.itemSanitize) {
        const sanitizedItems = value.map(item =>
          typeof item === "string"
            ? sanitizeContent(item, {
                maxLength: validation.itemMaxLength || 128,
                allowedAliases: options?.allowedAliases || [],
                maxBotMentions: options?.maxBotMentions,
              })
            : item
        );
        return { isValid: true, normalizedValue: sanitizedItems };
      }
    }

    return { isValid: true, normalizedValue: value };
  }

  if (validation.type === "boolean") {
    if (typeof value !== "boolean") {
      return {
        isValid: false,
        error: `Line ${lineNum}: ${itemType} '${fieldName}' must be a boolean`,
      };
    }
    return { isValid: true, normalizedValue: value };
  }

  if (validation.type === "number") {
    if (typeof value !== "number") {
      return {
        isValid: false,
        error: `Line ${lineNum}: ${itemType} '${fieldName}' must be a number`,
      };
    }
    return { isValid: true, normalizedValue: value };
  }

  // No specific type validation, return as-is
  return { isValid: true, normalizedValue: value };
}

/**
 * Execute custom validation rules
 * @param {Object} item - The item to validate
 * @param {string} customValidation - The custom validation rule identifier
 * @param {number} lineNum - Line number for error messages
 * @param {string} itemType - The item type for error messages
 * @returns {{isValid: boolean, error?: string}|null}
 */
function executeCustomValidation(item, customValidation, lineNum, itemType) {
  if (!customValidation) {
    return null;
  }

  // Parse custom validation rule
  if (customValidation.startsWith("requiresOneOf:")) {
    const fields = customValidation.slice("requiresOneOf:".length).split(",");
    const hasValidField = fields.some(field => item[field] !== undefined);
    if (!hasValidField) {
      return {
        isValid: false,
        error: `Line ${lineNum}: ${itemType} requires at least one of: ${fields.map(f => `'${f}'`).join(", ")} fields`,
      };
    }
  }

  if (customValidation === "startLineLessOrEqualLine") {
    if (item.start_line !== undefined && item.line !== undefined) {
      const startLine = typeof item.start_line === "string" ? parseInt(item.start_line, 10) : item.start_line;
      const endLine = typeof item.line === "string" ? parseInt(item.line, 10) : item.line;
      if (startLine > endLine) {
        return {
          isValid: false,
          error: `Line ${lineNum}: ${itemType} 'start_line' must be less than or equal to 'line'`,
        };
      }
    }
  }

  if (customValidation === "parentAndSubDifferent") {
    // Normalize values for comparison
    const normalizeValue = v => (typeof v === "string" ? v.toLowerCase() : v);
    if (normalizeValue(item.parent_issue_number) === normalizeValue(item.sub_issue_number)) {
      return {
        isValid: false,
        error: `Line ${lineNum}: ${itemType} 'parent_issue_number' and 'sub_issue_number' must be different`,
      };
    }
  }

  return null;
}

/**
 * Validate a safe output item against its type configuration
 * @param {Object} item - The item to validate
 * @param {string} itemType - The item type (e.g., "create_issue")
 * @param {number} lineNum - Line number for error messages
 * @param {ValidateOptions} [options] - Optional sanitization options
 * @returns {{isValid: boolean, normalizedItem?: Object, error?: string}}
 */
function validateItem(item, itemType, lineNum, options) {
  const validationConfig = loadValidationConfig();
  const typeConfig = validationConfig[itemType];

  if (!typeConfig) {
    // Unknown type - let the caller handle this
    return { isValid: true, normalizedItem: item };
  }

  const normalizedItem = { ...item };
  const errors = [];

  // Run custom validation first if defined
  if (typeConfig.customValidation) {
    const customResult = executeCustomValidation(item, typeConfig.customValidation, lineNum, itemType);
    if (customResult && !customResult.isValid) {
      return customResult;
    }
  }

  // Validate each configured field
  for (const [fieldName, validation] of Object.entries(typeConfig.fields)) {
    const fieldValue = item[fieldName];
    const result = validateField(fieldValue, fieldName, validation, itemType, lineNum, options);

    if (!result.isValid) {
      errors.push(result.error);
    } else if (result.normalizedValue !== undefined) {
      normalizedItem[fieldName] = result.normalizedValue;
    }
  }

  if (errors.length > 0) {
    return { isValid: false, error: errors[0] }; // Return first error
  }

  return { isValid: true, normalizedItem };
}

/**
 * Check if a type has validation configuration
 * @param {string} itemType - The item type
 * @returns {boolean}
 */
function hasValidationConfig(itemType) {
  const validationConfig = loadValidationConfig();
  return itemType in validationConfig;
}

/**
 * Get the validation configuration for a type
 * @param {string} itemType - The item type
 * @returns {TypeValidationConfig|undefined}
 */
function getValidationConfig(itemType) {
  const validationConfig = loadValidationConfig();
  return validationConfig[itemType];
}

/**
 * Get all known safe output types
 * @returns {string[]}
 */
function getKnownTypes() {
  const validationConfig = loadValidationConfig();
  return Object.keys(validationConfig);
}

module.exports = {
  // Main validation functions
  validateItem,
  validateField,
  validatePositiveInteger,
  validateOptionalPositiveInteger,
  validateIssueOrPRNumber,
  validateIssueNumberOrTemporaryId,

  // Configuration accessors
  loadValidationConfig,
  resetValidationConfigCache,
  getMaxAllowedForType,
  getMinRequiredForType,
  hasValidationConfig,
  getValidationConfig,
  getKnownTypes,

  // Constants
  MAX_BODY_LENGTH,
  MAX_GITHUB_USERNAME_LENGTH,
};
